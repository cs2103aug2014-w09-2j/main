//@author: a0119378u



	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java
	 */

	// these are for Display method.
	private static final String MESSAGE_DISPLAY_SUCCESSFULLY = "Tasks are displayed successfully.\n";

	// these are for Save and Reload.
	private static final String ERROR_FAIL_SAVE_TO_FILE = "Fail to save the Storage to file\n";
	private static final String MESSAGE_SAVE_SUCCESSFUL = "The Storage is saved to file successfully.\n";
	private static final String MESSAGE_RELOAD_SUCCESSFULLY = "The Storage is reloaded successfully.\n";

	public static Feedback feedback;

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java
	 */

	/**
	 * Called by Controller to initialize Executor. Splits into cases for
	 * processing in Executor component
	 * 
	 * @param command
	 *            ExecutableCommand from Controller.
	 * 
	 * @return a Feedback object
	 * 
	 */
	public static Feedback proceedAnalyzedCommand(ExecutableCommand command) {
		feedback = new Feedback(false);

		if (command.equals(null)) {
			feedback.setMessageShowToUser(StringFormat.EXE_ERROR_NULL_EXECUTABLE_COMMAND);
			return feedback;
		}

		switch (command.getAction()) {
		case StringFormat.ADD:
			feedback = performAddAction(command);
			break;

		case StringFormat.DELETE:
			feedback = performDeleteAction(command);
			break;

		case StringFormat.UPDATE:
			feedback = performUpdateAction(command);
			break;

		case StringFormat.CLEAR:
			feedback = performClearAction();
			break;

		case StringFormat.DISPLAY:
			feedback = performDisplayAction(command);
			break;

		case StringFormat.SORT:
			feedback = performSortAction(command);
			break;

		case StringFormat.SEARCH:
			feedback = performSearchAction(command);
			break;

		case StringFormat.UNDO:
			feedback = performUndoAction();
			break;

		case StringFormat.REDO:
			feedback = performRedoAction();
			break;

		case StringFormat.RELOAD:
			feedback = performReloadAction();
			break;

		case StringFormat.EXIT:
			feedback = performExitAction();
			break;

		case StringFormat.DONE:
			feedback = performDoneAction(command);
			break;

		default:
			feedback.setMessageShowToUser(String.format(
					StringFormat.EXE_ERROR_INVALID_COMMAND_ACTION,
					command.getAction()));
			return feedback;
		}

		if (feedback.getResult()) {
			saveUserCommand(command);
		}
		addInDisplayMessage(feedback);

		return feedback;
	}

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java
	 */

	/**
	 * Adds a Task object to Storage. Returns a Feedback object to show to a
	 * user.
	 *
	 * @param command
	 *            ExecutableCommand from Controller. Need the Task Attributes
	 *            inside the Object.
	 * 
	 * @return a Feedback object
	 * 
	 */
	private static Feedback performAddAction(ExecutableCommand command) {
		Feedback fb = new Feedback(StringFormat.ADD, false);

		String name = command.getTaskName();
		String description = command.getTaskDescription();
		String location = command.getTaskLocation();
		String priority = command.getTaskPriority();
		String startDateTimeString = command.getTaskStart();
		String endDateTimeString = command.getTaskEnd();

		Date startDateTime = convertStringToDate(startDateTimeString);
		Date endDateTime = convertStringToDate(endDateTimeString);

		try {
			Task newTask = createNewTask(name, description, startDateTime,
					endDateTime, location, priority);
			fb.setResult(Storage.add(newTask));
		} catch (Exception e) {
			fb.setMessageShowToUser(e.getMessage());
		}

		if (fb.getResult()) {
			fb.setMessageShowToUser(String.format(
					StringFormat.EXE_MSG_ADD_SUCCESSFUL, name));
		}

		return fb;
	}

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java
	 */

	/**
	 * Sorts a index array from a big number to a small number.
	 * 
	 * @param targetTaskIndexArray
	 *            Rearrange the order to avoid the change of list size when
	 *            small index is deleted.
	 * 
	 */
	private static void sortFromBigToSmall(
			ArrayList<Integer> targetTaskIndexArray) {
		Comparator<Integer> reverseComparator = Collections.reverseOrder();
		Collections.sort(targetTaskIndexArray, reverseComparator);
	}

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java
	 */

	/**
	 * Performs a/multiple delete action(s) in Storage. Deletes tasks displayed
	 * to a user.
	 *
	 * @return a Feedback object
	 * 
	 */
	private static Feedback performClearAction() {
		Feedback fb = new Feedback(StringFormat.CLEAR, false);

		int sizeOfDisplayTaskList = Storage.getDisplayTaskListSize();
		for (int i = sizeOfDisplayTaskList; i >= 1; i--) {
			int index = i - 1; // index in storage start from zero.
			try {
				fb.setResult(Storage.delete(index));
			} catch (Exception e) {
				fb.setMessageShowToUser(e.getMessage());
				return fb;
			}
		}

		if (fb.getResult()) {
			fb.setMessageShowToUser(StringFormat.EXE_MSG_CLEAR_SUCCESSFUL);
		}

		return fb;
	}

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java
	 */

	/**
	 * Displays the current taskList to a user using an arrayList. Displays the
	 * passed time task using two boolean arrays.
	 * 
	 * @para command ExecutableCommand passed from Controller. Need the
	 *       indicator inside.
	 * 
	 * @return a Feedback object
	 * 
	 */
	private static Feedback performDisplayAction(ExecutableCommand command) {
		Feedback fb = new Feedback(StringFormat.DISPLAY, false);
		if (command.getIndicator().size() != 1) {
			fb.setMessageShowToUser(StringFormat.EXE_ERROR_NO_TASK_LIST_INDICATOR);
			return fb;
		}

		String targetListIndicator = command.getIndicator().get(0);
		try {
			fb.setResult(Storage.display(targetListIndicator));
		} catch (Exception e) {
			fb.setResult(false);
			fb.setMessageShowToUser(e.getMessage());
		}

		if (fb.getResult()) {
			fb.setMessageShowToUser(MESSAGE_DISPLAY_SUCCESSFULLY);
		}

		return fb;
	}

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java
	 */

	/**
	 * Performs a exit action with a command object passed from the
	 * proceedAnalyzedCommand method
	 * 
	 * @return a Feedback object
	 * 
	 */
	private static Feedback performExitAction() {
		Feedback fb = new Feedback(StringFormat.EXIT, false);

		// check whether the storage can store the information into a file.
		try {
			Storage.saveFile();
		} catch (Exception e) {
			fb.setMessageShowToUser(String.format(ERROR_FAIL_SAVE_TO_FILE));
			return fb;
		}

		fb.setResult(true);
		fb.setMessageShowToUser(String.format(MESSAGE_SAVE_SUCCESSFUL));

		return fb;
	}

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java
	 */

	/**
	 * Adds a task into a history list as done.
	 * 
	 * @param command
	 *            ExecutableCommand Object passed from Controller.
	 * 
	 * @return a Feedback object
	 */
	private static Feedback performDoneAction(ExecutableCommand command) {
		Feedback fb = new Feedback(StringFormat.DONE, false);
		ArrayList<Integer> targetIndexList = command.getTaskId();

		for (int i = 0; i < targetIndexList.size(); i++) {
			int index = targetIndexList.get(i);
			index--; // index in storage start from zero.
			try {
				fb.setResult(Storage.done(index));
			} catch (Exception e) {
				fb.setMessageShowToUser(e.getMessage());
				return fb;
			}
		}

		fb.setResult(true);
		fb.setMessageShowToUser(StringFormat.EXE_MSG_DONE_SUCCESSFUL);

		return fb;
	}

	/**
	 * Return a feedback object to user
	 * 
	 * @return a Feedback object
	 * 
	 */
	public static Feedback getFeedback() {
		return feedback;
	}

	/**
	 * Saves user's commands in a Stack
	 * 
	 * @param command
	 *            ExecutableCommand Object passed in.
	 * 
	 */
	private static void saveUserCommand(ExecutableCommand command) {
		if (!command.getAction().equals("undo")
				&& !command.getAction().equals("redo")
				&& !command.getAction().equals("reload")) {
			commandStack.push(command);
		}
	}

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java
	 */

	/**
	 * Set displayed messages passed from Storage.
	 * 
	 * @param fb
	 *            feedback object that will be returned to Controller.
	 * 
	 */
	private static void addInDisplayMessage(Feedback fb) {
		fb.setTaskStringList(Storage.getStringFormatOfList());
		fb.setPassStartTimeIndicator(Storage.getPassStartTimeList());
		fb.setPassEndTimeIndicator(Storage.getPassEndTimeList());
		try {
			fb.setListNameIndicator(Storage.listContainsDisplayList());
		} catch (Exception e) {
			fb.setMessageShowToUser(e.getMessage());
		}
	}

	/**
	 * Converts a String of Date to the actual date.
	 * 
	 * @param dateTimeString
	 * 
	 * @return
	 * 
	 */
	private static Date convertStringToDate(String dateTimeString) {
		if (dateTimeString.equals("")) {
			return null;
		}

		Long dateTimeLong = Long.parseLong(dateTimeString);
		Date dateTimeDate = new Date(dateTimeLong);

		return dateTimeDate;
	}

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java
	 */

	/**
	 * Creates a new Task Object based on the attributes.
	 * 
	 * @param name
	 *            name string from ExecutableCommand Object
	 * @param description
	 *            description string from ExecutableCommand Object
	 * @param location
	 *            location string from ExecutableCommand Object
	 * @param priority
	 *            priority string from ExecutableCommand Object
	 * @param startDateTime
	 *            startDateTime long string from ExecutableCommand Object
	 * @param endDateTime
	 *            endDateTime long string from ExecutableCommand Object
	 * @throws Exception
	 *             throw Exception if the name is null or empty String.
	 * 
	 */
	private static Task createNewTask(String name, String description,
			Date startDateTime, Date endDateTime, String location,
			String priority) throws Exception {

		if (name.equals(null) || name.equals("")) {
			throw new Exception("Null task name");
		}

		Task newTask = new Task(name);

		if (!(description.equals(""))) {
			newTask.setTaskDescription(description);
		}
		if (!(startDateTime == null)) {
			newTask.setStartDateTime(startDateTime);
		}
		if (!(endDateTime == null)) {
			newTask.setEndDateTime(endDateTime);
		}
		if (!(location.equals(""))) {
			newTask.setTaskLocation(location);
		}
		if (!(priority.equals(""))) {
			newTask.setTaskPriority(priority);
		}

		return newTask;
	}
}
	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Executor.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Feedback.java
	 */

import java.util.ArrayList;



public class Feedback {
	
	// action that trigger the feedback
	private String action;

	// attributes
	private boolean result;
	private String listNameIndicator;
	private String messageShowToUser;

	// ArrayList only for display method.
	private ArrayList<String> taskStringListShowToUser = new ArrayList<String>();
	
	// boolean arrays for task pass the date
	private boolean[] passStartTimeTaskIndexIndicator = {};
	private boolean[] passEndTimeTaskIndexIndicator = {};

	/**
	 * Constructor
	 */
	
	Feedback(boolean result) {
		this.action = "";
		this.result = result;
		this.messageShowToUser = "";
	}
	Feedback(String action, boolean result){
		this.action = action;
		this.result = result;
		this.messageShowToUser = "";
	}

	/**
	 * Set methods
	 */
	
	public void setAction(String action){
		this.action = action;
	}

	public void setResult(boolean result) {
		this.result = result;
	}

	public void setMessageShowToUser(String message) {
		this.messageShowToUser = message;
	}

	public void setTaskStringList(ArrayList<String> taskList) {
		this.taskStringListShowToUser = taskList;
	}
	
	public void setPassStartTimeIndicator(boolean[] indicatorArray){
		this.passStartTimeTaskIndexIndicator = indicatorArray;
	}
	
	public void setPassEndTimeIndicator (boolean[] indicatorArray){
		this.passEndTimeTaskIndexIndicator = indicatorArray;
	}
	
	public void setListNameIndicator(String indicator){
		this.listNameIndicator = indicator;
	}

	/**
	 * Get methods
	 */
	
	public String getAction(){
		return action;
	}

	public boolean getResult() {
		return result;
	}

	public String getMessageShowToUser() {
		return messageShowToUser;
	}

	public ArrayList<String> getTaskStringList() {
		return taskStringListShowToUser;
	}
	
	public boolean[] getPassStartTimeIndicator (){
		return passStartTimeTaskIndexIndicator;
	}
	
	public boolean[] getPassEndTimeListIndicator() {
		return passEndTimeTaskIndexIndicator;
	}
	
	public String getListNameIndicator(){
		return listNameIndicator;
	}

}

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Feedback.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\FileInOut.java
	 */

import java.io.*;
import java.util.Date;
import java.util.logging.Logger;

/**
 * Description :
 * 
 * FileInOut class in charge of save taskList from memory to .txt file and
 * reload a txt file to taskList.
 * 
 *
 *
 */
public class FileInOut {
	private static final Logger LOGGER = Logger.getLogger(FileInOut.class
			.getName());

	private File file;
	private FileReader fileReader;
	private BufferedReader bufferedReader;
	private FileWriter fileWriter;

	public FileInOut() {
	}

	/**
	 * Save the given taskList to local file.
	 * 
	 * @param targetList
	 * @param fileName
	 * @return
	 * @throws Exception
	 */
	public boolean saveTaskList(List targetList, String fileName)
			throws Exception {
		file = new File(fileName);

		if (!file.exists()) {
			file.createNewFile();
		}

		fileWriter = new FileWriter(file);
		fileWriter.write(getFirstLineMsg());

		for (int index = 0; index < targetList.size(); index++) {
			Task currTask = targetList.getTaskByIndex(index);
			String currTaskString = convertTaskToString(currTask);
			fileWriter.write(currTaskString);
		}

		fileWriter.close();

		LOGGER.info("==============\n" + "FileInOut : Save \n"
				+ "====================\n");
		return true;
	}

	/**
	 * Read the file and create a taskList from the file.
	 * 
	 * @param fileName
	 * @return
	 * @throws Exception
	 */
	public List readTaskList(String fileName) throws Exception {
		file = new File(fileName);
		List resultList = new List();

		if (!file.exists()) {
			throw new Exception(
					StringFormat.IO_MESSAGE_TASK_LIST_FILE_NOT_EXIST);
		}

		fileReader = new FileReader(file);
		bufferedReader = new BufferedReader(fileReader);
		// read the first line.
		String messageLine = bufferedReader.readLine();
		String taskString = bufferedReader.readLine();
		while (taskString != null) {
			System.out.println("task Strng : " + taskString);
			Task task = converStringToTask(taskString);
			resultList.addTask(task);
			taskString = bufferedReader.readLine();
		}

		LOGGER.info("==============\n" + "FileInOut : Read \n"
				+ "	resultList size: " + resultList.size() + "\n"
				+ "====================\n");
		return resultList;

	}

	/**
	 * Get the first line to be written in the file. Include time info.
	 * 
	 * @return String format of the message.
	 */
	public String getFirstLineMsg() {
		Date now = new Date();
		String msgString = StringFormat.IO_MESSAGE_SAVED_IN_FILE;
		String dateString = StringFormat.IO_DATE_FORMAT_SAVED_IN_FILE
				.format(now) + "\n";

		return msgString + dateString;
	}

	/**
	 * Convert a Task Object to String. Follow the given Format.
	 * 
	 * @param task
	 * @return
	 */
	public String convertTaskToString(Task task) {
		String emptySpace = " ";
		String resultString = task.getTaskName().concat("~");

		// add in description information.

		resultString = resultString.concat(task.getTaskDescription());

		resultString = resultString.concat("~");

		// add in start date time information.
		if (task.getStartDateTime() != null) {
			resultString = resultString.concat(task
					.getLongStringFormatStartDateTime());
		}
		resultString = resultString.concat("~");

		// add in end date time information.
		if (task.getEndDateTime() != null) {
			resultString = resultString.concat(task
					.getLongStringFormatEndDateTime());
		}
		resultString = resultString.concat("~");

		// add in location information.
		resultString = resultString.concat(task.getTaskLocation());
		resultString = resultString.concat("~");

		// add in priority information.
		resultString = resultString.concat(task.getTaskPriority());
		resultString = resultString.concat(emptySpace);

		resultString = resultString.concat("\n");
		return resultString;
	}

	/**
	 * Convert a String in the saved .txt file to a Task Object.
	 * 
	 * @param taskString
	 * @return
	 * @throws Exception
	 */

	public Task converStringToTask(String taskString) throws Exception {
		String[] taskAttributes = taskString.split("~");

		if (taskAttributes.length != 6) {
			throw new Exception(String.format(
					StringFormat.IO_ERROR_INVALID_TASK_RECORD, taskString));
		} else {

			Task task = new Task();
			task.setTaskName(taskAttributes[0].trim());

			task.setTaskDescription(taskAttributes[1].trim());
			if (!taskAttributes[2].trim().equals("")) {
				task.setStartDateTime(new Date(Long
						.parseLong(taskAttributes[2])));
			}
			if (!taskAttributes[3].trim().equals("")) {
				task.setEndDateTime(new Date(Long.parseLong(taskAttributes[3])));
			}
			task.setTaskLocation(taskAttributes[4].trim());
			task.setTaskPriority(taskAttributes[5].trim());
			return task;
		}
	}

}

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\FileInOut.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\List.java
	 */

import java.util.ArrayList;
import java.util.Collections;

/**
 * Description : 
 * 
 * List Object contains Task Objects.
 *
 *
 */
public class List {
	ArrayList<Task> taskList = new ArrayList<Task>();
	String taskListName;

	/**
	 * Constructor
	 */
	List() {
	}

	List(String name) {
		this.taskListName = name;
	}

	/**
	 * Methods
	 */
	
	/**
	 * Set the nameString of this List.
	 * @param name
	 */
	public void setListName(String name) {
		this.taskListName = name;
	}
	/**
	 * Get the name of this taskList.
	 * @return
	 */
	public String getListName(){
		return taskListName;
	}
	
	/**
	 * Get the size of taskList.
	 * @return
	 */
	public int size() {
		return taskList.size();
	}
	
	/**
	 * Add a new task into the taskList.
	 * @param t
	 * @return
	 */
	public boolean addTask(Task t) {
		if (t == null) {
			return false;
		}
		taskList.add(t);
		return true;
	}

	/**
	 * Delete a task by the index of the task in the ArrayList.
	 * 
	 * @param index
	 * @return
	 */
	public boolean deleteTaskByIndex(int index) {
		if (index < 0 || index >= taskList.size()) {
			return false;
		}
		taskList.remove(index);
		return true;
	}

	/**
	 * Delete a task by it unique taskId.
	 * 
	 * @param id
	 * @return
	 */
	public boolean deleteTaskById(int id) {
		for (int index = 0; index < taskList.size(); index++) {
			Task currTask = taskList.get(index);
			if (currTask.getTaskId() == id) {
				taskList.remove(index);
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Return the Task object in the given position of taskList.
	 * @param index
	 * @return
	 */
	public Task getTaskByIndex(int index) {
		if (index < 0 || index >= taskList.size()) {
			return null;
		}
		return taskList.get(index);
	}
	
	/**
	 * Get the index of task with provided Id. 
	 * Search through the list.
	 * @param targetTaskId
	 * @return
	 */
	public int getIndexByTaskId(int targetTaskId){
		int result = -1;
		for (int index=0; index<taskList.size(); index++){
			Task currTask = taskList.get(index);
			if (currTask.getTaskId() == targetTaskId){
				result = index;
				break;
			}
		}
		return result;
	}
	/**
	 * Sort the taskList array. The key is in the Task object.
	 */
	public void sortList() {
		Collections.sort(taskList);
	}

	/**
	 * Add in a task to a certain position in taskList array, and remove the
	 * original one.
	 * 
	 * @param index
	 * @param task
	 * @return
	 */
	public boolean setTask(int index, Task task) {
		if (index < 0 || index >= taskList.size()) {
			return false;
		}
		taskList.set(index, task);
		return true;
	}

	/**
	 * Delete all tasks in this list.
	 */
	public void clean() {
		taskList.clear();
	}

	/**
	 * Reture true if taskList contains a task with the same Id as given
	 * targetId.
	 * 
	 * @param targetTaskId
	 * @return
	 */
	public boolean containsTaskId(int targetTaskId) {
		for (int index = 0; index < taskList.size(); index++) {
			Task currTask = taskList.get(index);
			if (currTask.getTaskId() == targetTaskId) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Return a new list contains the same task objects.
	 * 
	 * @return
	 */
	public List copy() {
		List copyList = new List();
		for (int index = 0; index < size(); index++) {
			copyList.addTask(taskList.get(index));
		}
		return copyList;
	}

	/**
	 * Return an arrayList contains the String format of every task inside the
	 * taskList.
	 * 
	 * @return
	 */
	public ArrayList<String> convertToString() {
		ArrayList<String> resultList = new ArrayList<String>();

		for (int index = 0; index < size(); index++) {
			resultList.add(taskList.get(index).toString());
		}
		return resultList;
	}

	/**
	 * Task has unique TaskId when the program is run. Use this feature to
	 * compare two list.
	 * 
	 * @param list
	 * @return
	 */
	public boolean equals(List list) {
		for (int index = 0; index < taskList.size(); index++) {
			Task currTask = taskList.get(index);
			int currId = currTask.getTaskId();
			if (!list.containsTaskId(currId)) {
				return false;
			}
		}
		return true;
	}
}

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\List.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Storage.java
	 */


import java.io.*;
import java.util.*;
import java.util.logging.Logger;

/**
 * Description of Storage :
 * 
 * 1. Storage contains mainTaskList, doneTaskList, displayTaskList. Tasks in
 * displayTaskList will be show to user. 2. The User action will first be done
 * in the displayTaskList. And then perform the same action to either
 * mainTaskList or doneTaskList using the unique taskId. 3. Index shown to user
 * start from 1; index in each taskList start from zero; TaskId start from zero.
 * 
 *
 *
 */
public class Storage {

	private static final Logger LOGGER = Logger.getLogger(Storage.class
			.getName());

	// this is the two list of tasks.
	private static List mainTaskList = new List(StringFormat.MAIN_TASK_LIST);
	private static List doneTaskList = new List(StringFormat.DONE_TASK_LIST);
	private static Integer taskId = -1; // Unique taskId start from 0.

	// these are for display.
	public static List displayTaskList = new List(
			StringFormat.DISPLAY_TASK_LIST);
	public static boolean[] passStartTimeList = {};
	public static boolean[] passEndTimeList = {};

	// the file that used to save current tasks when user exit the program.
	private static String mainTaskListFileName = "taskList.txt";
	private static String doneTaskListFileName = "doneList.txt";
	private static FileInOut fileProcesser = new FileInOut();

	/**
	 * Provide a unique taskId to the task. Add a task in the mainTaskList, set
	 * the display list to be mainTaskList. User will see the mainTaskList after
	 * the add action.
	 * 
	 * @param Task
	 * @throws Exception
	 */

	public static boolean add(Task task) throws Exception {
		// check whether the task object is null.
		if (task == null) {
			throw new Exception(StringFormat.STR_ERROR_NULL_TASK_OBJECT);
		}
		// check whether task has task name.
		if (task.getTaskName().equals("")) {
			throw new Exception(StringFormat.STR_ERROR_NO_TASK_NAME);
		}
		// check the validity of Start & End time.
		if (task.getStartDateTime() != null && task.getEndDateTime() != null
				&& task.getStartDateTime().after(task.getEndDateTime())) {
			throw new Exception(String.format(
					StringFormat.STR_ERROR_START_TIME_AFTER_END_TIME,
					task.getFormatStartDateTime(), task.getFormatEndDateTime()));
		}
		// check the validity of Start time.
		if (task.getStartDateTime() != null
				&& task.getStartDateTime().before(new Date())) {

			throw new Exception(String.format(
					StringFormat.STR_ERROR_START_TIME_BEFORE_CURRENT_TIME,
					task.getFormatStartDateTime()));
		}
		// check the validity of End time.
		if (task.getEndDateTime() != null
				&& task.getEndDateTime().before(new Date())) {

			throw new Exception(String.format(
					StringFormat.STR_ERROR_END_TIME_BEFORE_CURRENT_TIME,
					task.getFormatEndDateTime()));
		}

		task.setTaskId(obtainNewTaskId());
		mainTaskList.addTask(task);
		setDisplayList(mainTaskList);

		LOGGER.info("==============\n" + "Storage : Add \n"
				+ "\tAdd a new task. " + "	task id : " + task.getTaskId()
				+ "\n" + "====================\n");

		return true;
	}

	/**
	 * Delete a task from displayTaskList, and find the task with same taskId in
	 * either mainTaskList or doneTaskList. Remove that task also. Throws
	 * Exception when invalid task index is passed in.
	 * 
	 * @param index
	 * @return
	 * @throws Exception
	 */
	public static boolean delete(int index) throws Exception {
		if (index < 0 || index >= displayTaskList.size()) {
			throw new Exception(String.format(
					StringFormat.STR_ERROR_INVALID_TASK_INDEX, (index + 1)));
		}
		Task targetTask = displayTaskList.getTaskByIndex(index);
		int targetTaskId = targetTask.getTaskId();

		if (mainTaskList.containsTaskId(targetTaskId)) {
			mainTaskList.deleteTaskById(targetTaskId);
		} else if (doneTaskList.containsTaskId(targetTaskId)) {
			doneTaskList.deleteTaskById(targetTaskId);
		} else { // not supposed to reach this line;
			throw new Exception(StringFormat.STR_ERROR_INCONSISTENT_TASKID);
		}
		displayTaskList.deleteTaskByIndex(index);

		setDisplayList(displayTaskList);

		LOGGER.info("==============\n" + "Storage : Delete \n"
				+ "Task index : " + index + "\n" + "\tdisplaytasklist size : "
				+ displayTaskList.size() + "\n" + "\tmaintasklist size : "
				+ mainTaskList.size() + "\n" + "====================\n");

		return true;
	}

	/**
	 * Move the targetTask from mainTaskList to historyTaskList. Throws
	 * Exception if the taskId is not inside the mainTaskList.
	 * 
	 * @param index
	 * @return
	 * @throws Exception
	 */

	public static boolean done(int index) throws Exception {
		if (index < 0 || index >= displayTaskList.size()) {
			throw new Exception(String.format(
					StringFormat.STR_ERROR_INVALID_TASK_INDEX, index));
		}

		Task targetTask = displayTaskList.getTaskByIndex(index);
		int targetTaskId = targetTask.getTaskId();

		if (!mainTaskList.containsTaskId(targetTaskId)) {
			throw new Exception(
					StringFormat.STR_ERROR_CANNOT_DONE_TASK_IN_DONE_LIST);
		}

		mainTaskList.deleteTaskById(targetTaskId);
		displayTaskList.deleteTaskByIndex(index);

		doneTaskList.addTask(targetTask);

		LOGGER.info("==============\n" + "Storage : Done \n"
				+ "\tDone a task. " + "\n" + "\tTask index: " + index + "\n"
				+ "\tCurrent Task List size: " + "\n"
				+ "\tDisplaytasklist size : " + displayTaskList.size() + "\n"
				+ "\tMaintasklist size : " + mainTaskList.size() + "\n"
				+ "====================\n");

		return true;
	}

	/**
	 * Update a task's certain attributes. Find the task index in mainTaskList
	 * by the taskId. Reset the updated task Object to the same index in
	 * mainTaskList. Throws Exception if the target task is inside doneTaskList.
	 * 
	 * @param taskId
	 * @param updateIndicator
	 * @param updateKeyValue
	 * @return
	 * @throws Exception
	 */

	public static boolean update(int index, String updateIndicator,
			String updateKeyValue) throws Exception {

		if (index < 0 || index >= displayTaskList.size()) {
			throw new Exception(String.format(
					StringFormat.STR_ERROR_INVALID_TASK_INDEX, (index + 1)));
		}
		// remove the old task in both display list and main list.
		Task targetTask = displayTaskList.getTaskByIndex(index);
		int targetTaskId = targetTask.getTaskId();
		int taskIndexInMainTaskList = mainTaskList
				.getIndexByTaskId(targetTaskId);
		// user cannot update tasks that has been done.
		if (doneTaskList.containsTaskId(targetTaskId)) {
			throw new Exception(StringFormat.STR_ERROR_UPDATE_DONE_TASK);
		}
		// update the old task.
		update(targetTask, updateIndicator, updateKeyValue);
		mainTaskList.setTask(taskIndexInMainTaskList, targetTask);
		setDisplayList(displayTaskList);

		LOGGER.info("==============\n" + "Storage : Update \n"
				+ "\tUpdate a task. " + "Task index : " + index + "\n"
				+ "\tTask Index: " + index + "\n" + "\tTask Id: "
				+ targetTaskId + "\n" + "\tupdateIndicator: " + updateIndicator
				+ "\n" + "\tupdateKeyValue: " + updateKeyValue + "\n"
				+ "====================\n");
		return true;
	}

	/**
	 * Update a task Object with specified indicator and value.
	 * 
	 * @param targetTask
	 * @param updateIndicator
	 * @param updateKeyValue
	 * @throws Exception
	 */
	private static void update(Task targetTask, String updateIndicator,
			String updateKeyValue) throws Exception {
		switch (updateIndicator) {
		case StringFormat.NAME:
			targetTask.setTaskName(updateKeyValue);
			break;
		case StringFormat.DESCRIPTION:
			targetTask.setTaskDescription(updateKeyValue);
			break;
		case StringFormat.START:
			Date newStartDateTime = new Date(Long.parseLong(updateKeyValue));
			targetTask.setStartDateTime(newStartDateTime);
			break;
		case StringFormat.END:
			Date newEndDateTime = new Date(Long.parseLong(updateKeyValue));
			targetTask.setEndDateTime(newEndDateTime);
			break;
		case StringFormat.START_DATE:
			Date newStartDate = new Date(Long.parseLong(updateKeyValue));
			targetTask.setStartDate(newStartDate);
			break;
		case StringFormat.START_TIME:
			Date newStartTime = new Date(Long.parseLong(updateKeyValue));
			targetTask.setStartTime(newStartTime);
			break;
		case StringFormat.END_DATE:
			Date newEndDate = new Date(Long.parseLong(updateKeyValue));
			targetTask.setEndDate(newEndDate);
			break;
		case StringFormat.END_TIME:
			Date newEndTime = new Date(Long.parseLong(updateKeyValue));
			targetTask.setEndTime(newEndTime);
			break;
		case StringFormat.LOCATION:
			targetTask.setTaskLocation(updateKeyValue);
			break;
		case StringFormat.PRIORITY:
			targetTask.setTaskPriority(updateKeyValue);
			break;

		default:
			assert false : updateIndicator;
			throw new Exception(String.format(
					StringFormat.STR_ERROR_INVALID_INDICATOR, updateIndicator));

		}
	}

	/**
	 * Clean all the tasks inside mainTaskList and doneTaskList. Set the
	 * displayTaskList to be mainTaskList.
	 * 
	 * @return
	 */
	public static boolean clean() {
		clean(mainTaskList);
		clean(doneTaskList);
		clean(displayTaskList);
		return true;
	}

	/**
	 * Clean tasks inside taskList with targetListName.
	 * 
	 * @param targetListName
	 * @return
	 * @throws Exception
	 */
	public static boolean clean(String targetListName) throws Exception {
		switch (targetListName) {
		case StringFormat.MAIN_TASK_LIST:
			clean(mainTaskList);
			break;
		case StringFormat.DONE_TASK_LIST:
			clean(doneTaskList);
			break;
		default:
			throw new Exception(String.format(
					StringFormat.STR_ERROR_INVALID_TASK_LIST_INDICATOR,
					targetListName));
		}

		return clean(displayTaskList);
	}

	/**
	 * Clear tasks inside target TaskList.
	 * DisplayTaskList will not change.
	 * @param targetList
	 * @return
	 */
	private static boolean clean(List targetList) {
		targetList.clean();
		setDisplayList(displayTaskList);

		LOGGER.info("==============\n" + "Storage : Clean \n"
				+ "\ttaskList name: " + targetList.getListName() + "\n"
				+ "====================\n");
		return true;
	}

	/**
	 * Set displayList to be task list indicate by targetListIndicator. And
	 * display the String format of displayList
	 * 
	 * @param targetListIndicator
	 * @return
	 * @throws Exception
	 */

	public static boolean display(String targetListIndicator) throws Exception {
		switch (targetListIndicator) {
		case StringFormat.MAIN_TASK_LIST:
			setDisplayList(mainTaskList);
			break;
		case StringFormat.DONE_TASK_LIST:
			setDisplayList(doneTaskList);
			break;
		default:
			throw new Exception(String.format(
					StringFormat.STR_ERROR_INVALID_TASK_LIST_INDICATOR,
					targetListIndicator));
		}

		LOGGER.info("==============\n" + "Storage : Display \n"
				+ "\ttaskList name: " + targetListIndicator + "\n"
				+ "====================\n");
		return true;
	}

	/**
	 * Sort the task in taskList corresponding to parameter key. if the key is
	 * not valid, tasks are sorted by name(default);
	 * 
	 * @return
	 */

	public static boolean sort(String key) {
		return sort(key, displayTaskList);
	}

	private static boolean sort(String key, List targetList) {
		Task.setSortKey(key);
		targetList.sortList();

		setDisplayList(displayTaskList);

		LOGGER.info("==============\n" + "Storage : Sort \n"
				+ "\ttaskList name: " + targetList.getListName() + "\n"
				+ "\tkey: " + key + "\n" + "====================\n");
		return true;
	}

	/**
	 * Search the task in taskList corresponding to parameter key.
	 * 
	 * @return
	 */
	public static boolean search(String indicator, String searchValue) {
		return search(displayTaskList, indicator, searchValue);
	}

	private static boolean search(List targetList, String indicator,
			String searchValue) {
		List newList = new List();
		for (int index = 0; index < targetList.size(); index++) {
			Task currTask = targetList.getTaskByIndex(index);
			if (currTask.get(indicator).toLowerCase().trim()
					.contains(searchValue.toLowerCase().trim())) {
				newList.addTask(currTask);
			}
		}
		setDisplayList(newList);

		LOGGER.info("==============\n" + "Storage : Search \n"
				+ "\tindicator: " + indicator + "\n" + "\tsearchValue: "
				+ searchValue + "\n" + "\tresultTaskListSize: "
				+ newList.size() + "\n" + "====================\n");
		return true;
	}

	/**
	 * Check which task is passed the start and end time. Task that pass
	 * start(or end) time will be recorded in boolean array.
	 */
	private static void checkTime() {
		checkTime(displayTaskList);
	}

	private static void checkTime(List targetList) {
		passStartTimeList = new boolean[targetList.size()];
		passEndTimeList = new boolean[targetList.size()];

		for (int index = 0; index < targetList.size(); index++) {
			Task currTask = targetList.getTaskByIndex(index);
			Date currStartTime = currTask.getStartDateTime();
			Date currEndTime = currTask.getEndDateTime();
			Date currTime = new Date(System.currentTimeMillis());

			if (currStartTime != null) {
				if (currTime.after(currStartTime)) {
					passStartTimeList[index] = true;
				}
			}
			if (currEndTime != null) {
				if (currTime.after(currEndTime)) {
					passEndTimeList[index] = true;
				}
			}
		}

		LOGGER.info("==============\n" + "Storage : checkTime \n"
				+ "\ttargetListSize: " + targetList.size() + "\n"
				+ "====================\n");
	}

	/**
	 * Get the Pass Start Time indicator array of displayTaskList.
	 * 
	 * @return
	 */
	public static boolean[] getPassStartTimeList() {
		checkTime();
		return passStartTimeList;
	}

	/**
	 * Get the Pass Start Time indicator array of targetList.
	 * 
	 * @param targetList
	 * @return
	 */
	public static boolean[] getPassStartTimeList(List targetList) {
		checkTime(targetList);
		return passStartTimeList;
	}

	/**
	 * Get the Pass End Time indicator array of displayTaskList.
	 * 
	 * @return
	 */
	public static boolean[] getPassEndTimeList() {
		checkTime();
		return passEndTimeList;
	}

	/**
	 * Get the Pass End Time indicator array of targetList.
	 * 
	 * @param targetList
	 * @return
	 */
	public static boolean[] getPassEndTimeList(List targetList) {
		checkTime(targetList);
		return passEndTimeList;
	}

	/**
	 * Get the string format of all tasks in taskList and store in arrayList.
	 * 
	 * @return
	 */
	public static ArrayList<String> getStringFormatOfList() {
		return getStringFormatOfList(displayTaskList);
	}

	private static ArrayList<String> getStringFormatOfList(List targetList) {
		ArrayList<String> resultList = new ArrayList<String>();

		for (int index = 0; index < targetList.size(); index++) {
			Task currTask = targetList.getTaskByIndex(index);
			resultList.add(currTask.toString());
		}
		LOGGER.info("==============\n" + "Storage : getDisplayList \n"
				+ "	resultList size " + resultList.size() + "\n"
				+ "====================\n");

		return resultList;
	}

	/**
	 * Save the mainTaskList and doneTaskList to .txt file.
	 * 
	 * @throws IOException
	 */

	public static void saveFile() throws Exception {
		fileProcesser.saveTaskList(mainTaskList, mainTaskListFileName);
		fileProcesser.saveTaskList(doneTaskList, doneTaskListFileName);

		LOGGER.info("==============\n" + "Storage : SaveFile \n"
				+ "====================\n");
	}

	/**
	 * Reload mainTaskList and doneTaskList from .txt file
	 * 
	 * @throws Exception
	 */

	public static void reloadFile() throws Exception {
		mainTaskList.clean();
		doneTaskList.clean();
		mainTaskList = fileProcesser.readTaskList(mainTaskListFileName);
		doneTaskList = fileProcesser.readTaskList(doneTaskListFileName);

		resetTaskId();
		setDisplayList(mainTaskList);

		LOGGER.info("==============\n" + "Storage : ReloadFile \n"
				+ "====================\n");
	}

	private static void setDisplayList(List targetList) {
		displayTaskList = targetList.copy();
		checkTime();

		LOGGER.info("==============\n" + "Storage : Set display list \n"
				+ "====================\n");
	}

	/**
	 * Return a unique taskId for new Task. And reset TaskId is necessary.
	 * 
	 * @return
	 */
	public static int obtainNewTaskId() {
		if (taskId == Integer.MAX_VALUE) {
			resetTaskId();
		}
		taskId++;

		return taskId;
	}

	/**
	 * Get the size of displayTaskList.
	 * 
	 * @return
	 */
	public static int getDisplayTaskListSize() {
		return displayTaskList.size();
	}

	/**
	 * There will become a lot unused TaskId after a lot of delete action. If
	 * Integer TaskId is out of range when create a new Task, this method will
	 * reset the TaskId to fill the empty holes.
	 */
	public static void resetTaskId() {
		taskId = -1; // set the start taskId to be 0;
		for (int index = 0; index < doneTaskList.size(); index++) {
			int currId = obtainNewTaskId();
			Task currTask = doneTaskList.getTaskByIndex(index);
			currTask.setTaskId(currId);
		}
		for (int index = 0; index < mainTaskList.size(); index++) {
			int currId = obtainNewTaskId();
			Task currTask = mainTaskList.getTaskByIndex(index);
			currTask.setTaskId(currId);
		}
	}

	/**
	 * Find whether mainTaskList or doneTaskList contains the displayList by
	 * search for the taskId in displayList.
	 * 
	 * @return
	 * @throws Exception
	 */
	public static String listContainsDisplayList() throws Exception {
		if (displayTaskList.size() == 0) {
			return StringFormat.MAIN_TASK_LIST;
		}
		Task exampleTask = displayTaskList.getTaskByIndex(0);
		int exampleTaskId = exampleTask.getTaskId();

		if (mainTaskList.containsTaskId(exampleTaskId)) {
			return StringFormat.MAIN_TASK_LIST;
		} else if (doneTaskList.containsTaskId(exampleTaskId)) {
			return StringFormat.DONE_TASK_LIST;
		} else { // should not reach this line.
			throw new Exception(
					StringFormat.STR_ERROR_DISPLAY_LIST_BELONG_TO_NO_LIST);
		}

	}

	/**
	 * These three below method is only for Unit Test.
	 */
	public static List getMainTaskList() {
		return mainTaskList;
	}

	public static List getDoneTaskList() {
		return doneTaskList;
	}

	public static List getDisplayTaskList() {
		return displayTaskList;
	}

}

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Storage.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\StringFormat.java
	 */

	/**
	 * Format and Static String in FileInOut
	 */
	public static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(
			"yyyy.MM.dd HH:mm");
	public static final SimpleDateFormat DATE_FORMAT_SHOWN_TO_USER = new SimpleDateFormat(
			"dd/MM/yyyy 'at' hh:mm a");
	public static final SimpleDateFormat IO_DATE_FORMAT_SAVED_IN_FILE = new SimpleDateFormat(
			"E yyyy.MM.dd 'at' hh:mm:ss a zzz");
	public static final String IO_MESSAGE_SAVED_IN_FILE = "Last saved point: ";
	// indicate name-description-start-end-location-priority.
	public static final String IO_TASK_STRING_FORMAT_SAVED_IN_FILE = "%s-%s-%s-%s-%s-%s\n";
	public static final String IO_MESSAGE_TASK_LIST_FILE_NOT_EXIST = "TaskListFile not exist.\n";
	public static final String IO_ERROR_INVALID_TASK_RECORD = "Invalid task record: %s\n";

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\StringFormat.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\StringFormat.java
	 */

	/**
	 * Message show to the user in Executor
	 */
	public static final String EXE_ERROR_NULL_EXECUTABLE_COMMAND = "Null command.\n";
	public static final String EXE_ERROR_INVALID_COMMAND_ACTION = "Invalid command action: %s.\n";
	// Add
	public static final String EXE_MSG_ADD_SUCCESSFUL = "\"%s\" is added successfully.\n";
	// Delete
	public static final String EXE_MSG_DELETE_SUCCESSFUL = "A task is deleted successfully.\n";
	public static final String MSG_DELETE_MULTIPLE_TASKS_SUCCESSFUL = "%d tasks are deleted successfully.\n";
	// Done
	public static final String EXE_MSG_DONE_SUCCESSFUL = "Add done task to history successfully.\n";
	// Display
	public static final String EXE_ERROR_NO_TASK_LIST_INDICATOR = "No Task List indicator.\n";
	// Clear
	public static final String EXE_MSG_CLEAR_SUCCESSFUL = "All tasks are cleared successfully.\n";

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\StringFormat.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\StringFormat.java
	 */

	/**
	 * Message show to the user in Storage
	 */
	// In Add Method
	public static final String STR_ERROR_NULL_TASK_OBJECT = "Cannot add a null task.\n";
	public static final String STR_ERROR_NO_TASK_NAME = "Cannot add a task without a name.\n";
	public static final String STR_ERROR_START_TIME_AFTER_END_TIME = "Start time is after End time. Start time : %s; End time : %s.\n";
	public static final String STR_ERROR_START_TIME_BEFORE_CURRENT_TIME = "Start time is before current time. Start time : %s.\n";
	public static final String STR_ERROR_END_TIME_BEFORE_CURRENT_TIME = "End time is before current time. End time : %s.\n";

	// In Delete, Update Method
	public static final String STR_ERROR_INVALID_TASK_INDEX = "Task index is out of range. Index : %d.\n";
	public static final String STR_ERROR_INVALID_INDICATOR = "The update indicator '%s' is invalid.\n";
	public static final String STR_ERROR_UPDATE_DONE_TASK = "Cannot update done tasks.\n";
	public static final String STR_ERROR_INCONSISTENT_TASKID = "Task in displayList is not consistent with either mainTaskList nor History.";
	// In Display, Clean Method
	public static final String STR_ERROR_INVALID_TASK_LIST_INDICATOR = "No such taskList. List name : %s.\n";

	// In Done Method
	public static final String STR_ERROR_CANNOT_DONE_TASK_IN_DONE_LIST = "The task has been done.\n";

	// query the display list
	public static final String STR_ERROR_DISPLAY_LIST_BELONG_TO_NO_LIST = "This list belongs to no list.\n";

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\StringFormat.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Task.java
	 */

import java.util.Date;

public class Task implements Comparable<Task>{

	// task attributes.
	private String taskName;
	private Date startDateTime;
	private Date endDateTime;
	private String taskDescription;
	private String taskLocation;
	private String taskPriority;
	
	public boolean passStartDateTime = false;
	public boolean passEndDateTime = false;
	
	private int taskId;
	
	// the sortKey is name by default;
	private static String sortKey = "name";

	/**
	 * Constructor
	 */
	Task (){
		this.taskName = "";
		this.startDateTime = null;
		this.endDateTime = null;
		this.taskDescription = "";
		this.taskLocation = "";
		this.taskPriority = "";
	}
	Task (String nameString){
		this.taskName = nameString;
		this.startDateTime = null;
		this.endDateTime = null;
		this.taskDescription = "";
		this.taskLocation = "";
		this.taskPriority = "";
	}
	Task (String nameString, int taskId){
		this.taskName = nameString;
		this.startDateTime = null;
		this.endDateTime = null;
		this.taskDescription = "";
		this.taskLocation = "";
		this.taskPriority = "";
		this.taskId = taskId;
	}

	/**
	 * Set methods
	 */

	public void setTaskName(String name) {
		this.taskName = name;
	}
	
	/**
	 * Set startDateTime from a given Date Object.
	 * @param date
	 */
	public void setStartDateTime(Date date) {
		this.startDateTime = date;
	}
	
	/**
	 * Set endDateTime from a given Date Object.
	 * @param date
	 */
	public void setEndDateTime(Date date){
		this.endDateTime = date;
	}
	
	/**
	 * Set startDate from a given Date Object.
	 * @param date
	 */
	public void setStartDate(Date date){
		this.startDateTime.setYear(date.getYear());
		this.startDateTime.setMonth(date.getMonth());
		this.startDateTime.setDate(date.getDate());
	}
	
	/**
	 * Set endDate from a given Date Object.
	 * @param date
	 */
	public void setEndDate(Date date){
		this.endDateTime.setYear(date.getYear());
		this.endDateTime.setMonth(date.getMonth());
		this.endDateTime.setDate(date.getDate());
	}
	
	/**
	 * Set startTime from a given Date Object.
	 * @param date
	 */
	public void setStartTime(Date date){
		this.startDateTime.setHours(date.getHours());
		this.startDateTime.setMinutes(date.getMinutes());
	}
	
	/**
	 * Set endTime from a given Date Object.
	 * @param date
	 */
	public void setEndTime(Date date){
		this.endDateTime.setHours(date.getHours());
		this.endDateTime.setMinutes(date.getMinutes());
	}

	public void setTaskDescription(String des) {
		this.taskDescription = des.trim();
	}

	public void setTaskLocation(String loc) {
		this.taskLocation = loc.trim();
	}

	public void setTaskPriority(String prio) {
		this.taskPriority = prio.trim();
	}
	
	public void setTaskId(int taskId){
		this.taskId = taskId;
	}

	/**
	 * Get methods
	 */

	public String getTaskName() {
		return this.taskName;
	}
	
	/**
	 * return null is there is not startDateTime.
	 * @return
	 */
	public Date getStartDateTime() {
		return this.startDateTime;
	}
	
	/**
	 * return null is there is not endDateTime.
	 * @return
	 */
	public Date getEndDateTime(){
		return this.endDateTime;
	}
	
	/**
	 * Return String format of endDateTime.
	 * @return
	 */
	public String getFormatEndDateTime(){
		if (endDateTime == null){
			return "";
		}
		return StringFormat.DATE_FORMAT_SHOWN_TO_USER.format(endDateTime);
	}
	
	/**
	 * Return String format of startDateTime.
	 * @return
	 */
	public String getFormatStartDateTime(){
		if (startDateTime == null){
			return "";
		}
		return StringFormat.DATE_FORMAT_SHOWN_TO_USER.format(startDateTime);
	}
	
	/**
	 * Return Long String to represent startDateTime.
	 * @return
	 */
	public String getLongStringFormatStartDateTime(){
		if (startDateTime == null){
			return Long.MAX_VALUE + "";
		}
		return startDateTime.getTime() + "";
	}
	
	/**
	 * Return Long String to represent endDateTime.
	 * @return
	 */
	public String getLongStringFormatEndDateTime(){
		if (endDateTime == null){
			return Long.MAX_VALUE + "";
		}
		return endDateTime.getTime() + "";
	}
	
	public String getLongStringFormatStartDate(){
		if (startDateTime == null){
			return "";
		}
		String result = startDateTime.getYear() + "";
		result = result.concat(startDateTime.getMonth() + "");
		result = result.concat(startDateTime.getDate() + "");
		return result;
	}
	
	public String getLongStringFormatStartTime(){
		if (startDateTime == null){
			return "";
		}
		String result = startDateTime.getHours() + "";
		result = result.concat(startDateTime.getMinutes() + "");
		return result;
	}
	
	public String getLongStringFormatEndDate(){
		if (endDateTime == null){
			return "";
		}
		String result = endDateTime.getYear() + "";
		result = result.concat(endDateTime.getMonth() + "");
		result = result.concat(endDateTime.getDate() + "");
		return result;
	}
	
	public String getLongStringFormatEndTime(){
		if (endDateTime == null){
			return "";
		}
		String result = endDateTime.getHours() + "";
		result = result.concat(endDateTime.getMinutes() + "");
		return result;
	}

	public String getTaskDescription() {
		return this.taskDescription;
	}

	public String getTaskLocation() {
		return this.taskLocation;
	}

	public String getTaskPriority() {
		return this.taskPriority;
	}
	
	public int getTaskId(){
		return this.taskId;
	}
	
	/**
	 * get a certain attribute of the task.
	 * @param attribute
	 * @return
	 */
	public String get(String attribute){
		
		switch(attribute){
		case StringFormat.NAME: 
			return getTaskName();
			
		case StringFormat.DESCRIPTION:
			return getTaskDescription();
			
		case StringFormat.START:
			return getLongStringFormatStartDateTime();
			
		case StringFormat.END:
			return getLongStringFormatEndDateTime();
			
		case StringFormat.START_DATE:
			return getLongStringFormatStartDate();
			
		case StringFormat.START_TIME:
			return getLongStringFormatStartTime();
			
		case StringFormat.END_DATE:
			return getLongStringFormatEndDate();
			
		case StringFormat.END_TIME:
			return getLongStringFormatEndTime();
			
		case StringFormat.LOCATION:
			return taskLocation;
			
		case StringFormat.PRIORITY:
			return taskPriority;
			
		default:
			return taskName;
		}
	}

	/**
	 * Set a the static value sortKey.
	 * @param key
	 */
	public static void setSortKey(String key){
		sortKey = key;
	}
	
	
	@Override
	public int compareTo(Task o){
		Task that = (Task)o;
		String thisString = this.get(sortKey);
		String thatString = that.get(sortKey);
		
		if (sortKey.equals(StringFormat.PRIORITY)){			
			thisString = convertPriority(thisString);
			thatString = convertPriority(thatString);
		}
		
		return thisString.compareToIgnoreCase(thatString);
	}
	
	/**
	 * The user input priority may be ordered in High, Medium, Low.
	 * This method convert the priority into comparable string.
	 * @param priority
	 * @return
	 */
	private String convertPriority (String priority){
		if (priority.equals(StringFormat.HIGH_PRIORITY)){
			return "a";
		}else if (priority.equals(StringFormat.MEDIUM_PRIORITY)){
			return "b";
		}else if (priority.equals(StringFormat.LOW_PRIORITY)){
			return "c";
		}else {
			return "d";
		}
	}
	
	/**
	 * Task Id is unique.
	 */
	@Override
	public boolean equals(Object o){
		Task that = (Task) o;
		if (this.taskId != that.taskId){
			return false;
		}
		return true;
	}
	
	@Override
	public String toString(){
		String emptySpace = " ";
		String resultString = taskName.concat("~");
		
		// add in description information.
		if (!getTaskDescription().equals("")){
			resultString = resultString.concat(taskDescription);
		}else {
			resultString = resultString.concat(emptySpace);
		}
		resultString = resultString.concat("~");
		
		// add in start date time information.
		if (!(getStartDateTime() == null)){
			resultString = resultString.concat(getFormatStartDateTime());
		}else {
			resultString = resultString.concat(emptySpace);
		}
		resultString = resultString.concat("~");
		
		// add in end date time information.
		if (!(getEndDateTime() == null)){
			resultString = resultString.concat(getFormatEndDateTime());
		}else {
			resultString = resultString.concat(emptySpace);
		}
		resultString = resultString.concat("~");
		
		// add in location information.
		if (!getTaskLocation().equals("")){
			resultString = resultString.concat(getTaskLocation());
		}else {
			resultString = resultString.concat(emptySpace);
		}
		resultString = resultString.concat("~");
		
		// add in priority information.
		if (!getTaskPriority().equals("")){
			resultString = resultString.concat(getTaskPriority());
		}else {
			resultString = resultString.concat(emptySpace);
		}
		
		resultString = resultString.concat("\n");
		return resultString;
	}

}

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\Task.java





	/**
	 * origin: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\TestStorage.java
	 */

import static org.junit.Assert.*;

import java.util.Date;

import org.junit.Test;

/**
 * This test for Storage contains tests for ADD, DELETE, UPDATE, SORT, SEARCH.
 * The FileInOut and checkTime() will be tested in the Integrated Test for the
 * Software.
 *
 *
 */
public class TestStorage {

	@Test
	// Add normal Task Object.
	public void testAddNormalTask() {
		Storage.clean();
		Storage.resetTaskId();

		Task task1 = new Task("task1"); // Only with name.
		Task task2 = new Task("task2");
		{// With start date time.
			task2.setStartDateTime(new Date(Long.MAX_VALUE));
		}
		Task task3 = new Task("task3");
		{// With end date time.
			task3.setEndDateTime(new Date(Long.MAX_VALUE));
		}
		Task task4 = new Task("task4");
		{// With location.
			task4.setTaskLocation("SoC");
		}
		Task task5 = new Task("task5");
		{// With priority.
			task5.setTaskPriority("high");
		}

		boolean expectedResult = true;

		try {
			assertEquals(expectedResult, Storage.add(task1));
			assertEquals(expectedResult, Storage.add(task2));
			assertEquals(expectedResult, Storage.add(task3));
			assertEquals(expectedResult, Storage.add(task4));
			assertEquals(expectedResult, Storage.add(task5));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Test
	// Add null Task Object & Task without name.
	public void testAddTaskWithoutName() {
		Storage.clean();
		Storage.resetTaskId();

		Task task1 = null; // Null task.
		Task task2 = new Task();
		{// Only with start date time.
			task2.setStartDateTime(new Date());
		}
		Task task3 = new Task();
		{// Only with end date time.
			task3.setEndDateTime(new Date());
		}
		Task task4 = new Task();
		{// Only with location.
			task4.setTaskLocation("SoC");
		}
		Task task5 = new Task();
		{// Only with priority.
			task5.setTaskPriority("high");
		}

		String expectedResult1 = "Cannot add a null task.\n";
		String expectedResult2 = "Cannot add a task without a name.\n";
		String expectedResult3 = "Cannot add a task without a name.\n";
		String expectedResult4 = "Cannot add a task without a name.\n";
		String expectedResult5 = "Cannot add a task without a name.\n";

		try {
			Storage.add(task1);
		} catch (Exception e) {
			assertEquals(expectedResult1, e.getMessage());
			;
		}
		try {
			Storage.add(task2);
		} catch (Exception e) {
			assertEquals(expectedResult2, e.getMessage());
			;
		}
		try {
			Storage.add(task3);
		} catch (Exception e) {
			assertEquals(expectedResult3, e.getMessage());
			;
		}
		try {
			Storage.add(task4);
		} catch (Exception e) {
			assertEquals(expectedResult4, e.getMessage());
			;
		}
		try {
			Storage.add(task5);
		} catch (Exception e) {
			assertEquals(expectedResult5, e.getMessage());
			;
		}
	}

	@Test
	// Add Task Object with invalid time.
	public void testAddTaskWithInvalidTime() {
		Storage.clean();
		Storage.resetTaskId();

		Long time = System.currentTimeMillis();
		Long timeBeforeNow = time - 1000;
		Long timeAfterNow = time + 10000;
		Long timeEvenAfterNow = time + 100000;

		Task task1 = new Task("task1");
		{ // Start time is before current time.
			task1.setStartDateTime(new Date(timeBeforeNow));
		}
		Task task2 = new Task("task2");
		{ // End time is before current time.
			task2.setEndDateTime(new Date(timeBeforeNow));
		}
		Task task3 = new Task("task3");
		{ // Start time is after End time.
			task3.setStartDateTime(new Date(timeEvenAfterNow));
			task3.setEndDateTime(new Date(timeAfterNow));
		}

		String expectedResult1 = "Start time is before current time.";
		String expectedResult2 = "End time is before current time. ";
		String expectedResult3 = "Start time is after End time.";

		try {
			Storage.add(task1);
		} catch (Exception e) {
			assertEquals(true, e.getMessage().contains(expectedResult1));
			;
		}
		try {
			Storage.add(task2);
		} catch (Exception e) {
			assertEquals(true, e.getMessage().contains(expectedResult2));
			;
		}
		try {
			Storage.add(task3);
		} catch (Exception e) {
			assertEquals(true, e.getMessage().contains(expectedResult3));
			;
		}

	}

	@Test
	// Delete Task Object.
	public void testDeleteNormalIndex() {
		Storage.clean();
		Storage.resetTaskId();

		Task task1 = new Task("task1", 0);
		Task task2 = new Task("task2", 1);
		Task task3 = new Task("task3", 2);
		Task task4 = new Task("task4", 3);
		Task task5 = new Task("task5", 4);

		List expectedMainTaskList1 = new List();
		{
			expectedMainTaskList1.addTask(task2);
			expectedMainTaskList1.addTask(task3);
			expectedMainTaskList1.addTask(task4);
			expectedMainTaskList1.addTask(task5);
		}
		List expectedMainTaskList2 = new List();
		{
			expectedMainTaskList1.addTask(task3);
			expectedMainTaskList1.addTask(task4);
			expectedMainTaskList1.addTask(task5);
		}

		try {
			Storage.add(task1);
			Storage.add(task2);
			Storage.add(task3);
			Storage.add(task4);
			Storage.add(task5);

			Storage.delete(0);
			assertEquals(true,
					expectedMainTaskList1.equals(Storage.getMainTaskList()));

			Storage.delete(1);
			assertEquals(true,
					expectedMainTaskList2.equals(Storage.getMainTaskList()));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Test
	// Delete with invalid index.
	public void testDeleteInvalidIndex() {
		Storage.clean();
		Storage.resetTaskId();

		Task task1 = new Task("task1");
		Task task2 = new Task("task2");
		Task task3 = new Task("task3");

		String expectedResult1 = "Task index is out of range. Index : 0.\n";
		String expectedResult2 = "Task index is out of range. Index : 4.\n";

		try {
			Storage.clean();
			Storage.add(task1);
			Storage.add(task2);
			Storage.add(task3);

			Storage.delete(-1);
		} catch (Exception e) {
			assertEquals(expectedResult1, e.getMessage());
		}
		try {
			Storage.clean();
			Storage.add(task1);
			Storage.add(task2);
			Storage.add(task3);

			Storage.delete(3);
		} catch (Exception e) {
			assertEquals(expectedResult2, e.getMessage());
		}
	}

	@Test
	// update normal task object.
	public void testUpdateNormalIndicator() {
		Storage.clean();
		Storage.resetTaskId();

		Task task1 = new Task("task1", 0);
		Task task2 = new Task("task2", 1);
		Task task3 = new Task("task3", 2);

		List expectedDoneTaskList1 = new List();
		{
			expectedDoneTaskList1.addTask(task1);
			expectedDoneTaskList1.addTask(task2);
			expectedDoneTaskList1.addTask(task3);
		}
		List expectedDoneTaskList2 = new List();
		{
			expectedDoneTaskList2.addTask(task1);
			expectedDoneTaskList2.addTask(task2);
		}
		List expectedDoneTaskList3 = new List();
		{
			expectedDoneTaskList3.addTask(task1);
		}
		List expectedDoneTaskList4 = new List();

		try {
			Storage.clean();
			Storage.add(task1);
			Storage.add(task2);
			Storage.add(task3);

			assertEquals(true,
					expectedDoneTaskList4.equals(Storage.getDoneTaskList()));
		} catch (Exception e) {
			e.printStackTrace();
		}
		try {
			Storage.clean();
			Storage.add(task1);
			Storage.add(task2);
			Storage.add(task3);

			Storage.done(0);
			assertEquals(true,
					expectedDoneTaskList3.equals(Storage.getDoneTaskList()));
		} catch (Exception e) {
			e.printStackTrace();
		}
		try {
			Storage.clean();
			Storage.add(task1);
			Storage.add(task2);
			Storage.add(task3);

			Storage.done(0);
			Storage.done(0);
			assertEquals(true,
					expectedDoneTaskList2.equals(Storage.getDoneTaskList()));
		} catch (Exception e) {
			e.printStackTrace();
		}
		try {
			Storage.clean();
			Storage.add(task1);
			Storage.add(task2);
			Storage.add(task3);

			Storage.done(0);
			Storage.done(0);
			Storage.done(0);
			assertEquals(true,
					expectedDoneTaskList1.equals(Storage.getDoneTaskList()));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Test
	// clean taskList and doneList.
	public void testClean() {
		Storage.clean();
		Storage.resetTaskId();

		Task task1 = new Task("task1"); // Only with name.
		Task task2 = new Task("task2");
		{// With start date time.
			task2.setStartDateTime(new Date(Long.MAX_VALUE));
		}
		Task task3 = new Task("task3");
		{// With end date time.
			task3.setEndDateTime(new Date(Long.MAX_VALUE));
		}
		Task task4 = new Task("task4");
		{// With location.
			task4.setTaskLocation("SoC");
		}
		Task task5 = new Task("task5");
		{// With priority.
			task5.setTaskPriority("high");
		}

		int expectedTaskListSizeBeforeClean = 4;
		int expectedTaskListSizeAfterClean = 0;
		int expectedDoneListSizeBeforeClean = 1;
		int expectedDoneListSizeAfterClean = 0;

		try {
			Storage.add(task1);
			Storage.add(task2);
			Storage.add(task3);
			Storage.add(task4);
			Storage.add(task5);
			Storage.done(0);

			assertEquals(expectedTaskListSizeBeforeClean, Storage
					.getMainTaskList().size());
			assertEquals(expectedDoneListSizeBeforeClean, Storage
					.getDoneTaskList().size());

			Storage.clean();
			assertEquals(expectedTaskListSizeAfterClean, Storage
					.getMainTaskList().size());
			assertEquals(expectedDoneListSizeAfterClean, Storage
					.getDoneTaskList().size());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Test
	// Sort by name.
	public void testSortByName() {
		Storage.clean();
		Storage.resetTaskId();

		Task task1 = new Task("e"); // Only with name.
		Task task2 = new Task("d");
		Task task3 = new Task("c");
		Task task4 = new Task("b");
		Task task5 = new Task("a");

		try {
			Storage.add(task1);
			Storage.add(task2);
			Storage.add(task3);
			Storage.add(task4);
			Storage.add(task5);

			assertEquals(task1, Storage.getMainTaskList().getTaskByIndex(0));
			assertEquals(task2, Storage.getDoneTaskList().getTaskByIndex(1));
			assertEquals(task3, Storage.getDoneTaskList().getTaskByIndex(2));
			assertEquals(task4, Storage.getDoneTaskList().getTaskByIndex(3));
			assertEquals(task5, Storage.getDoneTaskList().getTaskByIndex(4));

			Storage.sort("name");

			assertEquals(task5, Storage.getMainTaskList().getTaskByIndex(0));
			assertEquals(task4, Storage.getDoneTaskList().getTaskByIndex(1));
			assertEquals(task3, Storage.getDoneTaskList().getTaskByIndex(2));
			assertEquals(task2, Storage.getDoneTaskList().getTaskByIndex(3));
			assertEquals(task1, Storage.getDoneTaskList().getTaskByIndex(4));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Test
	// Sort by priority.
	public void testSortByPriority() {
		Storage.clean();
		Storage.resetTaskId();

		Task task1 = new Task("e");
		{
			task1.setTaskPriority("low");
		}
		Task task2 = new Task("c");
		{
			task2.setTaskPriority("medium");
		}
		Task task3 = new Task("a");
		{
			task3.setTaskPriority("high");
		}

		try {
			Storage.add(task1);
			Storage.add(task2);
			Storage.add(task3);

			assertEquals(task1, Storage.getMainTaskList().getTaskByIndex(0));
			assertEquals(task2, Storage.getDoneTaskList().getTaskByIndex(1));
			assertEquals(task3, Storage.getDoneTaskList().getTaskByIndex(2));

			Storage.sort("priority");

			assertEquals(task3, Storage.getMainTaskList().getTaskByIndex(0));
			assertEquals(task2, Storage.getDoneTaskList().getTaskByIndex(1));
			assertEquals(task1, Storage.getDoneTaskList().getTaskByIndex(2));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Test
	// Search the name of Task.
	public void testSearchNormalCase() {
		Storage.clean();
		Storage.resetTaskId();

		Task task1 = new Task("e");
		{
			task1.setTaskPriority("low");
		}
		Task task2 = new Task("c");
		{
			task2.setTaskPriority("medium");
		}
		Task task3 = new Task("a");
		{
			task3.setTaskPriority("high");
		}

		try {
			Storage.add(task1);
			Storage.add(task2);
			Storage.add(task3);

			Storage.search("name", "a");
			assertEquals(task3, Storage.getDisplayTaskList().getTaskByIndex(0));

			Storage.display("mainTaskList");

			Storage.search("priority", "low");
			assertEquals(task1, Storage.getDisplayTaskList().getTaskByIndex(0));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Test
	// Search for invalid indicator of Task.
	public void testSearchInvalidIndicator() {
		Storage.clean();
		Storage.resetTaskId();

		Task task1 = new Task("e");
		{
			task1.setTaskPriority("low");
		}
		Task task2 = new Task("c");
		{
			task2.setTaskPriority("medium");
		}
		Task task3 = new Task("a");
		{
			task3.setTaskPriority("high");
		}

		int expectedDisplayListSize = 0;

		try {
			Storage.add(task1);
			Storage.add(task2);
			Storage.add(task3);

			Storage.search("name", "b");
			assertEquals(expectedDisplayListSize, Storage.getDisplayTaskList()
					.size());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

}

	// End of segment: C:\Users\user\Desktop\Repositories\cs2103-w09-2j\JOYTZ\src\TestStorage.java





